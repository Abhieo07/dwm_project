<!DOCTYPE html>
<html lang="en">
<head>
    <!-- ... (your meta tags and other head elements) ... -->
    <title>Main</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.7"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-matrix@1.1"></script>
    <script src="https://cdn.jsdelivr.net/npm/@sgratzl/chartjs-chart-boxplot@4.2.6/build/index.umd.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
</head>
<body>
    <h1>Analyze your data here!!</h1>
    <div>
        <h2>{{ clean }}</h2>
        <form method="post" enctype="multipart/form-data" id="file-upload">
            {% csrf_token %}
            <label for="file_">Upload your data here</label>
            <input id="file_" type="file" name='uploaded-file' accept=".csv, .json, .xlsx"/>
            <!-- <input type="submit" value="Upload"> -->
        </form>
        <div>
            <select name="chart-type" id="chart-type" class="">
                <option value="">Chart type</option>
            </select>
        </div>
        <div class="drop-menu">
            <div id="x-axis">
                <select id="x-columns" name="x-columns" class="options">
                    <option value="" disabled selected hidden>Select an option</option>
                </select>
            </div>
            <div id="y-axis">
                <select id="y-columns" name="y-columns" class="options">
                    <option value="">Select an option</option>
                </select>
            </div>
        </div>
        <!-- Add an empty div to hold the chart -->
        <div id="chart-container">
            <canvas id="chart" width="200px" height="200px"></canvas>
        </div>
    </div>

    <!-- <script>
        $(document).ready(function() {
            function handleFormSubmission(event) {
                event.preventDefault(); // Prevent the default form submission
    
                // Create a FormData object and append the file data
                var formData = new FormData();
                formData.append('uploaded-file', $('#file_')[0].files[0]);
    
                // Send an AJAX request to your Django view to get cleaned data
                $.ajax({
                    url: window.location.href,
                    type: 'POST',
                    data: formData,
                    processData: false, // Prevent jQuery from converting the data to a string
                    contentType: false, // Ensure the content type is set to multipart/form-data
                    headers: {
                        'X-CSRFToken': '{{ csrf_token }}'
                    },
                    success: function(response) {
                        if (response.data) {
                            console.log(response.data); // Log the response.data
                        }
                    },
                    error: function(err) {
                        console.log('AJAX request failed:', err);
                    }
                });
            }
    
            // Attach the form submission event to the form element
            $('#file-upload').submit(handleFormSubmission);
        });
    </script> -->
    
    <script>
        var previousChart = null;
        let chartType = 'scatter';
        let chartData = getRandomData();
        var chartOptions = ['scatter', 'bar', 'pie', 'line', 'heatmap', 'boxplot'];




        
        const typeChange = document.querySelector('#chart-type');
        typeChange.addEventListener('change', ()=>{
            
            console.log(typeChange.options[typeChange.selectedIndex].value);

            chartType = typeChange.options[typeChange.selectedIndex].value;
            if(previousChart){
                previousChart.destroy();
            }
            const ctx = document.getElementById('chart').getContext('2d');
            createChart(chartType,chartData,ctx);
        });

        function populateChartTypes(options) {
            var select = $('#chart-type');
            select.empty();  // Clear existing options

            select.append($('<option>').val("select-chart").text("select-chart"));

            $.each(options, function(index, option) {
                select.append($('<option>').val(option).text(option));
            });
        }

        function getRandomData() {
            // Generate random data for demonstration
            var x = [];
            var y = [];
            for (let index = 0; index < 30; index++) {
                x.push(Math.floor(Math.random() * 100)); 
            }
            for (let index = 0; index < x.length; index++) {
                y.push(Math.floor(Math.random() * 101))  
            }

            var regression = linearRegression(x, y);
            return {
                datasets: [{
                    label: 'Linear Regression',
                    data: x.map((x, i) => ({ x, y: regression.equation[0] * x + regression.equation[1] })),
                    showLine: true,
                    borderColor: 'blue',
                }, {
                    label: 'Data Points',
                    data: x.map((x, i) => ({ x, y: y[i] })),
                    pointBackgroundColor: 'red',
                }],
            };
        }

        function createChart(type, data, ctx, customOptions = {}) {
            if (previousChart) {
                previousChart.destroy();
                previousChart = null;
            }

            // Default chart options
            const defaultOptions = {
                responsive: true,
                scales: {
                    x: {
                        ticks: {
                            font: {
                                size: 16,
                            },
                        },
                    },
                    y: {
                        ticks: {
                            font: {
                                size: 16,
                            },
                        },
                    },
                },
            };

            // Merge the default options with custom options
            var options = {
                ...defaultOptions,
                ...customOptions,
            };
            if(type === 'heatmap'){
                type = 'matrix';
                options = data.options;
            }

            chart = new Chart(ctx, {
                type: type,
                data: data,
                options: options,
            });

            previousChart = chart;
        }

        function updateChart(data){
            // select x-column
            var x= document.querySelector("#x-columns");
            x = x.options[x.selectedIndex].value;
            
            // select y-column
            var y= document.querySelector("#y-columns");
            y = y.options[y.selectedIndex].value;

            // get chartData
            if(chartType === 'scatter'){
                var xValues = Object.values(data[x]);
                var yValues = Object.values(data[y]);

                console.log("chart-type scatter");
                chartData = linearRegData(xValues, yValues);
            }
            else if(chartType === 'bar'){
                console.log("chart-type bar");
                chartData = categoricalData(data);
            }
            else if(chartType === 'pie'){
                chartData = quantitativeData(data);
            }
            else if(chartType === 'line'){
                chartData = timeOrTrendData(data, x, y);
            }
            else if(chartType === 'heatmap'){
                chartData = heatmapData(data, x, y);
                console.log("Heat map triggered! ",chartType,chartData);
            }
            else if(chartType === 'boxplot'){
                chartData = boxplotData(data, x, y);
            }else{
                alert("Inalid Chart type!");
            }

            console.log(chartType, chartData);
            // create the chart
            const ctx = document.getElementById('chart').getContext('2d');
            createChart(chartType, chartData, ctx);
        }
        
        const linearRegData = (xValues, yValues) => {
            var regression = linearRegression(xValues, yValues);
            return {
                datasets: [{
                    label: 'Linear Regression',
                    data: xValues.map((x, i) => ({ x, y: regression.equation[0] * x + regression.equation[1] })),
                    showLine: true,
                    borderColor: 'blue',
                }, {
                    label: 'Data Points',
                    data: xValues.map((x, i) => ({ x, y: yValues[i] })),
                    pointBackgroundColor: 'red',
                }],
            }
        }

        const categoricalData = (data) => {

            var sums = {};

            // Iterate through the keys of the outer object
            Object.keys(data).forEach(function(key) {
                sums[key] = 0; // Initialize the sum to 0

                // Iterate through the values of the inner object
                Object.values(data[key]).forEach(function(value) {
                    if (typeof value === 'number') {
                        sums[key] += value; // Sum the numeric values
                    } else if (value === true) {
                        sums[key]++; // Count the 'true' values
                    }
                });
            });
            

            return {
                labels: Object.keys(sums),
                datasets: [{
                    label: 'Categorical Data',
                    data: Object.values(sums),
                    backgroundColor: 'blue', // Customize the background color
                }],
            };
        }

        const quantitativeData = (data) =>{
            // Extract labels from outer keys if the value is numeric
            const labels = Object.keys(data).filter(key => {
                return typeof Object.values(data[key])[0] === 'number';
            });

            // Calculate sums for each outer key
            const sums = labels.map(label => {
                return Object.values(data[label]).reduce((sum, value) => sum + value, 0);
            });


            console.log("data set for quantitative analysis",labels,sums);

            return {
                labels: labels,
                datasets: [{
                    label: "Quantative Data",
                    data: sums,
                    backgroundColor: ['red', 'green', 'blue'],
                }],
            }
        }

        const timeOrTrendData = (data, x="select-an-option", y="select-an-option") => {
            
            var labels = [];
            var datasets = [];

            if(x!="select-an-option" && y!="select-an-option"){
                labels = Object.values(data[x]);
                datasets = [{
                        label: x,
                        data: Object.values(data[x]),
                        backgroundColor:getRandomColor(),
                    },
                    {
                        label: y,
                        data: Object.values(data[y]),
                        backgroundColor:getRandomColor(),
                    },
                ]

            }
            else {
                Object.keys(data).forEach(function(key) {
                    var values = data[key];

                    // Check if the key resembles a date or time
                    if (/date|time|year|month|day/i.test(key)) {
                        if (isValidDate(values[0])) {
                            labels = Object.values(data[key]);
                        }
                    } 

                    // Check if the values are numeric
                    if (typeof values[0] === 'number' && !isNaN(values[0])) {
                        datasets.push({
                            label: key,
                            data: Object.values(values),
                            backgroundColor:getRandomColor(),
                        });
                    }
                });

            }

            console.log(labels,datasets);

            return {
                labels:labels,
                datasets:datasets,
            };
        }

        const heatmapData = (data,  x="select-an-option", y="select-an-option") => {
            const keys = Object.keys(data);
            const heatmapData = [];
            var xLabels = [];
            var yLabels = [];
            var heightC;
            var widthC;

            if(x!="select-an-option" && y!="select-an-option"){
                const obj1 = data[x];
                const obj2 = data[y];
                console.log(x,y,obj1,obj2,data)
                

                Object.keys(obj1).forEach((key) => {
                    const x = key;
                    const y = obj1[key];      // Get the value from obj1
                    var v;
                    if(typeof obj2[key] ==="boolean"){
                        v = obj2[key] ? 1 : 0;  // Use the value from obj2 to determine v
                    }else{
                        v = obj2[key];
                    }
                    heatmapData.push({ x, y, v });
                });
                xLabels = heatmapData.map(item => item.x);
                yLabels = Array.from(new Set(heatmapData.map(item => item.y)));
                heightC = yLabels.length;
                widthC = xLabels.length;
            }
            else{
                // Iterate through keys and reformat the data
                keys.forEach(xKey => {
                    Object.keys(data[xKey]).forEach(yKey => {
                        heatmapData.push({ x: yKey, y: xKey, v: data[xKey][yKey] ? 1 : 0 });
                    });
                });
                xLabels = Object.keys(keys[0]);
                yLabels = keys;
                heightC = widthC = keys.length - 1;
            }
            console.log("lengths ",heightC,widthC);
            
            return {
                datasets: [{
                    label:'Value',
                    data: heatmapData,
                    backgroundColor(context) {
                    const value = context.dataset.data[context.dataIndex].v;
                    const alpha = value;
                    return 'rgba(0, 128, 0, ' + alpha + ')';
                    },
                    borderColor(context) {
                    const value = context.dataset.data[context.dataIndex].v;
                    const alpha = value;
                    return 'rgba(0, 100, 0, ' + alpha + ')';
                    },
                    borderWidth: 1,
                    width: ({chart}) => (chart.chartArea || {}).width / widthC,
                    height: ({chart}) =>(chart.chartArea || {}).height / heightC
                }],
                options: {
                    plugins: {
                    legend: false,
                    tooltip: {
                        callbacks: {
                        title() {
                            return '';
                        },
                        label(context) {
                            const v = context.dataset.data[context.dataIndex];
                            return ['x: ' + v.x, 'y: ' + v.y, 'v: ' + v.v];
                        }
                        }
                    }
                    },
                    scales: {
                        x: {
                            type: 'category',
                            labels: xLabels,
                            ticks: {
                            display: true
                            },
                            title:{
                            text:"Records",
                            display:true
                            },
                            grid: {
                            display: false
                            }
                        },
                        y: {
                            type: 'category',
                            labels: yLabels,
                            offset: true,
                            ticks: {
                            display: true
                            },
                            grid: {
                            display: false
                            }
                        }
                    }
                },
            };
        };

        const boxplotData = (data) => {
            var labels = [];
            var datasets = [];

            Object.keys(data).forEach((key) => {
                var values = data[key];

                if (typeof values[0] === 'number' && !isNaN(values[0])) {
                    datasets.push({
                        data: Object.values(values),
                    });
                    labels.push(key);
                }
            });

            datasets = [{
                label:'Dataset',
                backgroundColor: getRandomColor(),
                data:datasets.map(item=>item.data),
            },]

            return {
                labels:labels,
                datasets:datasets,
                options: {
                    responsive: true,
                    legend: {
                        position: 'top',
                    },
                    title: {
                        display: true,
                        text: 'Box Plot'
                    }
                }
            }
        }

        function isValidDate(dateString) {
            var date = new Date(dateString);
            var timePattern = /^(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$/;
            return !isNaN(date) || timePattern.test(dateString);
        }

        // Function to generate random colors
        function getRandomColor() {
            const letters = '0123456789ABCDEF';
            let color = '#';
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }

        $(document).ready(function() {

            const ctx = document.getElementById('chart').getContext('2d');
            createChart(chartType, chartData, ctx);

            // populate chart-type options
            populateChartTypes(chartOptions);

            function handleFileChange(event) {
                // Create a FormData object and append the file data
                var formData = new FormData();
                formData.append('uploaded-file', event.target.files[0]);
    
                // Send an AJAX request to your Django view to get cleaned data
                $.ajax({
                    url: window.location.href,
                    type: 'POST',
                    data: formData,
                    processData: false, // Prevent jQuery from converting the data to a string
                    contentType: false, // Ensure the content type is set to multipart/form-data
                    headers: {
                        'X-CSRFToken': '{{ csrf_token }}'
                    },
                    success: function(response) {
                        var data = JSON.parse(response.data);

                        if (data) {
                            console.log(data); // Log the response.data
                            var columns = Object.keys(data);
                            populateOptions(columns);

                            const optionChange = document.querySelectorAll(".options, #chart-type");
                            optionChange.forEach(option => {
                                option.addEventListener('change', ()=>{
                                    updateChart(data);
                                });
                            });

                        }
                    },
                    error: function(err) {
                        console.log('AJAX request failed:', err);
                    }
                });
            }
    
            // Attach the file change event to the file input element
            $('#file_').on('change', handleFileChange);
        });


        function populateOptions(options) {
            var select = $('.options');
            select.empty();  // Clear existing options

            select.append($('<option>').val("select-an-option").text("select-an-option"));

            $.each(options, function(index, option) {
                select.append($('<option>').val(option).text(option));
            });
        }

        // Function to calculate linear regression
        function linearRegression(x, y) {
            var n = x.length;
            var sumX = x.reduce((a, b) => a + b, 0);
            var sumY = y.reduce((a, b) => a + b, 0);
            var sumXY = x.map((xi, i) => xi * y[i]).reduce((a, b) => a + b, 0);
            var sumX2 = x.map(xi => xi ** 2).reduce((a, b) => a + b, 0);
            var slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX ** 2);
            var intercept = (sumY - slope * sumX) / n;
            return { equation: [slope, intercept] };
        }

    </script>
    
    
</body>
</html>
